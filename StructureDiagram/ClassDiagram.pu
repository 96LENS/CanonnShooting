@startuml CannonShooting
title CannonShooting ClassMap

/'
オブジェクト指向のポイント
ドメイン(業務の関心事)のデータとロジックを一緒にしてオブジェクト単位でまとめる技法
手続き型はトップダウン、オブジェクト指向はパーツを作って関係を構築していくボトムアップ

1登場人物の整理 (業務の関心事を洗い出す)
ヒト(業務活動の当事者)：プレイヤー・敵
モノ(人が業務を遂行するときの関心の対象)：大砲・大砲の弾・エネミー、制限時間・スコア・HP
コト(事象)：大砲とエネミーの衝突、大砲の弾とエネミーの衝突

2各々の関心事を説明する
'/

'大砲のロジックをどのようにMonoBehaviourのメインルーチンに繋げるか (MonoBehaviourが何らかの形で知っている必要がある)
'Animationファイルの管理・再生制御をどのように行うか
'BarrelとLowerCarriageのドメインロジックがどのようにTransfromを知っているようにするか

/'=====================================================
Domain層 (今回はロジックもここにまとめる)
======================================================='/
Package Domain{
    Package Cannnon{

        class CannonManager{
            - List<CannonBase> _cannon
            + bool AddCannon()
            + bool RemoveCannon()
            + ICannon GetCannon()
        }
        CannonManager "1"-->"*" CannonBase : 生成時に登録 >

        '機能の使用を提供するインターフェース
        '機能を呼ぶ場合はこのインターフェースを通して呼ぶ
        interface ICannon{   
        }

        class CannonBase{
            - GameObject _root
        }
        CannonBase -down-|> ICannon

        class Cannon {
            - CannonBase _cannonBase
            - void Movement()
            - void Attack()
        }

        class LowerCarriage{
            - Transform LowerCarriage
            + void Rotate()
        }

        class Barrel{
            - Transform Barrel
            + void Rotate()
        }

    }

    Package Bullet{
        '弾の属性のEnumeration
        enum BulletType<<short>>{
            NORMAL
            MAGNUM
            POISON
            PARALYSIS
        }

        'Q. 残段数の管理
        class RemaingBullet{
            - int maxBullet
            - int nowBullet
            - void UpdateRemaingBullet()
            + bool IsMaxBullet()
        }
        

        class BulletCreator{
            - float _interval
            + bool IsCreateBullet()
            - void CountInterval()
            + void CreateBullet()
        }

        class Bullet <<MonoBehaviour>>{
            - BulletType _bulletType
        }
        Bullet *-- BulletType

    }

    Package Enemy{

        class EnemyBase
        {
            - float _moveSpeed
            - int _hitPoint
            + void Movement()
            + void Attack()
        }

        class Enemy{

        }
        Enemy --|> EnemyBase
    }

    Package Damage{

        Interface IDamage{
            
        }

        class Damage

    }
    Enemy --> IDamage

    Package HitPoint{

    }

    Package Score{

    }

    Package TimeLimit{

    }

    Package Utility{

        Interface BaseSystem{
            + void Initialize()
            + void FixedUpdate()
            + void Update()
            + void LateUpdate()
            + void Termination()
        }
    }
}

/'=====================================================
Application層 (Domain層の組み立て) Unityの繋ぎこみも担当
======================================================='/
Package Application{

    'キャノンのロジックモデル組み立て(ロジック自体はDomain層で記載する)
    class CannonModel{

    }
}

/'=====================================================
Presentation層 UIなど主にユーザーが見えるところ (MonoBehaviour継承クラスはここだけ)
======================================================='/

Package Presentation{

    'MonoBehaviourのライフサイクルを模したインターフェース
    'Application層での繋ぎこみはこのインターフェースの実装クラスとして記載する
    Interface IMonoBehaviourRoutine{
        void Awake()
        void OnEnable()
        void Start()
        void FixedUpdate()
        void Update() 
        void LateUpdate()
        void OnDisable()
        void OnDestroy()
    }

    'IMonoBehaviourの処理をUnity上のメインルーチンとして呼び出すためのクラス
    class MonoBehaviourUpdateManager{
        - List<IMonoBehaviourRoutine> _updateList
        - void Awake()
        - void OnEnable()
        - void Start()
        - void FixedUpdate()
        - void Update()
        - void LateUpdate()
        - void OnDisable()
        - void OnDestroy()
    }
    MonoBehaviourUpdateManager "1"--> "0..*" IMonoBehaviourRoutine : 更新 >
    MonoBehaviourUpdateManager --|> MonoBehaviourSingleton

    'MonoBehaviourクラス上でシングルトンを保証するクラス
    abstract MonoBehaviourSingleton<<MonoBehaviour>>{
        - T _instance
        - bool _isInitialized
        # virtual void Awake()
        # vritual void OnDestroy()
    }

    'GameObjectに貼り付けるコンポーネントの基礎クラス
    class ContainerBase{
        + bool IsSerializeFieldNullOrEmpty()     
    }
    ContainerBase --|> MonoBehaviourSingleton

    class CannonContainer{
        + GameObject barrel
        + GameObject lowerCarriage
    }
    CannonContainer --|> ContainerBase

    'ルーチンの基礎クラス、
    class MonoBehaviourRoutineBase<<Control>>{
        - Control _control
        + virtual void Awake()
        + virtual void OnEnable()
        + virtual void Start()
        + virtual void FixedUpdate()
        + virtual void Update() 
        + virtual void LateUpdate()
        + virtual void OnDisable()
        + virtual void OnDestroy()


    }
    MonoBehaviourRoutineBase ..|> IMonoBehaviourRoutine : 実装 > 
    MonoBehaviourRoutineBase --> MonoBehaviourUpdateManager : 生成時に登録 > 

    'キャノンの関係のUIと手続きの紐づけ
    class CannonPresenter{

    }
    CannonPresenter --|> MonoBehaviourRoutineBase
    CannonPresenter --> CannonContainer
}

CannonPresenter --> CannonModel

CannonModel --> Cannon

'Q.GameObjectの生成はオブジェクト単位でまとめたほうがいいのではないか？
@enduml